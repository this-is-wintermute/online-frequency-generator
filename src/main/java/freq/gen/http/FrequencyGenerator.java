package freq.gen.http;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

/**
 * A simple random frequency generator, using specified boundaries
 * and alteration speed.
 */
public class FrequencyGenerator implements Runnable {
    private static final Logger LOGGER = LoggerFactory.getLogger(FrequencyGenerator.class);

    private final double lowerBorder;
    private final double upperBorder;
    private final double defaultFreuency;
    private final double maxAlterationBetweenIteration;
    private final double maxDeviationFromDefault;

    private double previousFrequency;

    private static FrequencyGenerator singletonGenerator = null;
    private static ScheduledExecutorService executor = null;
    private static ScheduledFuture<?> generatorJob = null;


    /**
     * Creates a default frequency generator, altering 200 mHz around 50 Hz in 5 mHz steps
     */
    public FrequencyGenerator() {
        this(50.0, 0.2, 0.005);
    }

    /**
     * Creates a frequency generator with the given outline.
     */
    public FrequencyGenerator(double defaultFrequency, double maxDeviation, double maxAlterationPerIteration) {
        this.defaultFreuency = defaultFrequency;
        this.previousFrequency = defaultFrequency;
        this.maxDeviationFromDefault = Math.abs(maxDeviation);
        this.lowerBorder = defaultFrequency - Math.abs(maxDeviation);
        this.upperBorder = defaultFrequency + Math.abs(maxDeviation);
        this.maxAlterationBetweenIteration = Math.abs(maxAlterationPerIteration);
    }

    /**
     * Returns a new instance of the FrequencyGenerator, which is scheduled to update its frequency every 50ms,
     * using the default settings for the european power grid (50.0 Hz default frequency, max. 200 mHz deviation, max.
     * 50 ÂµHz/ms alteration speed.
     */
    public static FrequencyGenerator getTimeBasedInstance() {
        if( singletonGenerator == null ) {
            LOGGER.info("Creating auto-updating FrequencyGenerator instance");
            singletonGenerator = new FrequencyGenerator();
            executor = Executors.newSingleThreadScheduledExecutor();
            generatorJob = executor.scheduleAtFixedRate(singletonGenerator, 0, 100, TimeUnit.MILLISECONDS);
        }
        return singletonGenerator;
    }


    public static void stopTimeBasedInstance() {
        generatorJob.cancel(true);
        executor = null;
        singletonGenerator = null;
        LOGGER.info("Auto-updating FrequencyGenerator instance stopped.");
    }

    /**
     * Returns the frequency, generated by the previous datapoint plus a random value {@code E{-alteration .. +alteration}}
     */
    public double getFrequency() {
        double alteration = ( Math.random() * maxAlterationBetweenIteration * 2 ) - maxAlterationBetweenIteration;
        if( this.previousFrequency + alteration < this.lowerBorder ) {
            this.previousFrequency = this.lowerBorder;
        } else if ( this.previousFrequency + alteration > this.upperBorder ) {
            this.previousFrequency = this.upperBorder;
        } else {
            this.previousFrequency = this.previousFrequency + alteration;
        }
        LOGGER.info("New frequency is " + this.previousFrequency);
        return this.previousFrequency;
    }

    /**
     * Returns the latest frequency from the auto-updating singleton instance (gets created, if it doesn't exist).
     */
    public static double getLatestFrequency() {
        if( singletonGenerator == null ) {
            singletonGenerator = getTimeBasedInstance();
        }
        return singletonGenerator.previousFrequency;
    }


    @Override
    public void run() {
        singletonGenerator.getFrequency();
    }
}
